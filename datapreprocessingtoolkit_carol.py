# -*- coding: utf-8 -*-
"""DataPreprocessingToolkit-Carol.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yo0quYaiv-nFOO9BBI_P18b50pPlq6FT

# Data Preprocessing Tools

## Importing the libraries
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

"""## Importing the dataset"""

dataset = pd.read_csv('Data.csv')
X = dataset.iloc[:, :-1].values # get all columns except the last one
y = dataset.iloc[:, -1].values #get only the last column (usually represented as the dependent variable)

print(X)

print(y)

"""## Taking care of missing data"""

# In this piece of code we identify the empty cells and replace this nan by the average of that column
from sklearn.impute import SimpleImputer #we import the class SimpleImputer from the library sklearn
db = pd.read_csv('pima-indians-diabetes.csv')


X = db.iloc[:,:-1].values
y = db.iloc[:,-1].values
print(X)
print(y)
# Identify missing data (assumes that missing data is represented as NaN)
# Print the number of missing entries in each column
null_matrix = db.isnull() #binary matrix (true or false) depending if on that position there is an empty cell or not
null_count_per_column = db.isnull().sum() # count by column the empty cells (we apply one sum)

# Configure an instance of the SimpleImputer class
imputer = SimpleImputer(missing_values=np.nan, strategy='mean')
# Fit the imputer on the DataFrame. It just computes values, does not transform anything
imputer.fit(X[:,:])

# Apply the transform to the DataFrame
X[:,:]= imputer.transform(X[:,:])

#Print your updated matrix of features
print(X)

print(X)

"""## Encoding categorical data

### Encoding the Independent Variable
"""

from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder #HotEncoding is to replace the categorical data with canonic vectors
# e.g: we have Spain, Germany and France, in one column, so we create instead 3 columns, and code Spain as 1,0,0; Germany as 010, France 001
#in this way we do not have any numerical order that could bias our machine learning model
ct = ColumnTransformer(transformers=[('encoder', OneHotEncoder(), [0])], remainder='passthrough')
#this class requires two arguments, transformers needs three arguments aswell: type of transformation (encoding in our case)
# kind of encoding (onehot) and indexes of the columns we want to encode. REMAINDER is very important because it is what
#makes the ct keep the rest of the columns
X = np.array(ct.fit_transform(X))
# Essential to use np.array as ct does not return an array

print(X)

"""### Encoding the Dependent Variable"""

from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
y = le.fit_transform(y)

print(y)

"""## Splitting the dataset into the Training set and Test set"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 1)
print(X_train)
print(X_test)
print(y_train)
print(y_test)

"""## Feature Scaling"""

from sklearn.preprocessing import StandardScaler
sc = StandardScaler()
X_train = sc.fit_transform(X_train)
X_test = sc.transform(X_test)
print(X_train)
print(X_test)